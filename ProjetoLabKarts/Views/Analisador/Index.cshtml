@model IEnumerable<ProjetoLabKarts.Models.SessaoKart>
@using ProjetoLabKarts.Interop
@using System.Globalization
@using Newtonsoft.Json

@{
    ViewData["Title"] = "Análise de Sessões";
    var channelsByFile = (Dictionary<string, List<ChannelData>>)ViewBag.ChannelsByFile;
    var firstSession = Model.FirstOrDefault()?.NomeFicheiro;
    var selectedGraphs = (ViewBag.SelectedGraphs as IEnumerable<string>) ?? Enumerable.Empty<string>();
    var selectedProgressBars = (ViewBag.SelectedProgressBars as IEnumerable<string>) ?? Enumerable.Empty<string>();
    var voltasByFile = (Dictionary<string, List<ProjetoLabKarts.Interop.LapInfo>>)ViewBag.VoltasByFile;
}

<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <style>
        /* Painel lateral esquerdo 30% */
        .side-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 30%; /* ocupa 30% da largura */
        height: 100%;
        background: #fff; /* ou o que te apetecer */
        box-shadow: 2px 0 8px rgba(0,0,0,0.3);
        z-index: 9999;
        overflow-y: auto;
        transform: translateX(-100%);
        transition: transform .3s ease-in-out;
        }

        .side-panel.open {
        transform: translateX(0);
        }

        .side-panel .panel-header {
        padding: 1rem;
        border-bottom: 1px solid #ddd;
        display: flex;
        justify-content: space-between;
        align-items: center;
        }

        .side-panel .panel-body {
        padding: 1rem;
        }

        .d-none {
        display: none !important;
        }

        .chart-row {
        display: flex;
        justify-content: space-around;
        margin: 10px 0;
        }

        .chart {
        background: #222;
        padding: 5px;
        border-radius: 4px;
        }

        #gauges {
        display: flex;
        justify-content: space-around;
        margin: 10px;
        }

        .gauge {
        width: 180px;
        height: 180px;
        }

        .progress-vertical {
        width: 1.5rem;
        height: 200px; /* altura total da barra */
        background: #e9ecef;
        border-radius: 0.25rem;
        overflow: hidden;
        display: flex;
        flex-direction: column-reverse; /* o “fundo” fica em baixo */
        margin: 0 auto;
        }

        .progress-vertical .progress-bar {
        width: 100%;
        height: 0%; /* vai crescer em altura */
        transition: height .2s ease;
        position: relative;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        }

        .gauge-container {
        text-align: center;
        }

        .gauge-container .max-label .min-label {
        font-size: .8rem;
        margin-bottom: .25rem;
        }

        .gauge-container .current-label {
        font-size: .9rem;
        margin-top: .25rem;
        }

        .bar-label {
        position: absolute;
        bottom: 0.25rem; /* fixa junto ao fundo da barra */
        left: 50%; /* centra horizontalmente */
        transform: translateX(-50%);
        font-size: .75rem;
        color: #fff;
        pointer-events: none; /* para que não interfira no hover */
        }
    </style>
</head>

<div class="container modal-fullscreen">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div class="d-flex flex-column">
            <h2 class="mb-0">Sessões Selecionadas para Análise</h2>
            <p class="lead fs-6 mb-0">Análise da telemetria das sessões</p>
        </div>

        <div class="d-flex align-items-center gap-2">
            <button id="btnCompareLaps" class="btn btn-outline-primary" data-bs-toggle="modal" data-bs-target="#compareLapsModal">
                Comparar Voltas
            </button>

            <button id="btnShowDetails" class="btn btn-primary">
                Ver Detalhes dos Canais
            </button>

            <button type="button"
            onclick="window.history.back();"
            class="btn btn-outline-secondary">
                ← Voltar
            </button>
        </div>
    </div>


    <div class="row g-3 mb-4 align-items-stretch">
        <div class="col-md-4">
            <div class="card shadow border rounded-3 p-2 h-100">
                <div class="card-body d-flex flex-column gap-2">
                    <h5 class="card-title">Melhor Volta</h5>
                    <h3 class="card-text fw-bold">@ViewBag.melhorVolta</h3>
                    <small class="text-muted">
                        -@ViewBag.diferencaMelhorVoltaDosOutrosFicheiros para a Melhor Volta dos outros ficheiros
                    </small>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card shadow border p-2 h-100">
                <div class="card-body d-flex flex-column gap-2">
                    <h5 class="card-title">Número de Voltas</h5>
                    <h3 class="card-text fw-bold">@ViewBag.numeroDeVoltas</h3>
                    <small class="text-muted"></small>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card shadow border p-2 h-100">
                <div class="card-body d-flex flex-column gap-2">
                    <h5 class="card-title">Velocidade Máxima</h5>
                    <h3 class="card-text fw-bold">@ViewBag.velocidadeMaxima km/h</h3>
                    <small class="text-muted">
                        +@ViewBag.diferencaVelocidadeMaximaDosOutrosFicheiros para a Velocidade Máxima dos outros ficheiros
                    </small>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Comparar Voltas -->
    <div class="modal fade" id="compareLapsModal" tabindex="-1" aria-labelledby="compareLapsLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="compareLapsLabel">Comparar Voltas</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <div class="modal-body">
                    @foreach (var s in Model)
                    {
                        var laps = voltasByFile[s.NomeFicheiro];
                        <div class="mb-3">
                            <h6 class="fw-semibold">@s.NomeFicheiro</h6>
                            <div class="d-flex flex-wrap gap-2">
                                @for (int i = 0; i <= laps.Count - 1; i++)
                                {
                                    <div class="form-check">
                                        <input class="form-check-input compare-lap-checkbox" type="checkbox" value="@i" data-session="@s.NomeFicheiro" id="compareLap_@s.NomeFicheiro@i">
                                        <label class="form-check-label" for="compareLap_@s.NomeFicheiro@i">Volta @i</label>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="button" id="confirmCompareLaps" class="btn btn-primary">Comparar</button>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <!-- SidePanel com tabelas -->
        <div class="col-lg-5">

            @if (!Model.Any())
            {
                <div class="alert alert-warning">Nenhuma sessão foi selecionada.</div>
            }
            else
            {
                <div id="sidePanel" class="side-panel">
                    <div class="panel-header">
                        <h5>Detalhe dos Canais</h5>
                        <button id="btnHideDetails" class="btn-close" aria-label="Fechar"></button>
                    </div>

                    <div class="panel-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5>Sessões Carregadas</h5>
                            <button id="btnAddSession" class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#addSessionModal">+</button>
                        </div>

                        <!-- 1ª Tabela clicável -->
                        <table class="table table-borderless mb-4" id="sessionTable">
                            <tbody>
                                @foreach (var s in Model)
                                {
                                    var isActive = s.NomeFicheiro == firstSession ? "table-active" : "";
                                    <tr class="clickable-row @isActive" data-session="@s.NomeFicheiro" style="cursor:pointer">
                                        <td class="fw-semibold text-muted">
                                            @s.MelhorVolta - @s.NumeroMelhorVolta
                                        </td>
                                        <td class="text-end text-muted" style="white-space: nowrap;">
                                            @s.DataHoraInsercao.ToString("yyyy, MMM dd h:mm tt", System.Globalization.CultureInfo.InvariantCulture)
                                        </td>
                                        <td class="text-end">
                                            <button type="button" class="btn btn-sm btn-outline-danger btn-remove" title="Remover">
                                                <i class="bi bi-trash"></i>
                                            </button>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>

                        <!-- 2ª Tabela de detalhes -->
                        <h5>Detalhes da Sessão</h5>
                        <div id="channelDetails">
                            @foreach (var s in Model)
                            {
                                var isVisible = s.NomeFicheiro == firstSession ? "" : "d-none";
                                <div class="channel-details @isVisible" data-session="@s.NomeFicheiro">
                                    <div class="table-responsive mb-4">
                                        <table class="table table-borderless align-middle">
                                            <thead class="text-muted border-bottom">
                                                <tr>
                                                    <th>Número da Volta</th>
                                                    <th>Tempo da Volta (s)</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                @{
                                                    // Lista de LapInfo para esta sessão
                                                    var laps = voltasByFile[s.NomeFicheiro];
                                                }
                                                @foreach (var lap in laps)
                                                {
                                                    <tr>
                                                        <td>@(lap.LapIndex)</td>
                                                        <td>@lap.Duration.ToString("F3", CultureInfo.InvariantCulture)</td>
                                                    </tr>
                                                }
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            }
                        </div>

                        <!-- Modal de Adicionar Sessão sem filtragem -->
                        <div class="modal fade" id="addSessionModal" tabindex="-1" aria-labelledby="addSessionLabel" aria-hidden="true">
                            <div class="modal-dialog modal-lg">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 id="addSessionLabel" class="modal-title">Adicionar Sessões</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                                    </div>
                                    <div class="modal-body">
                                        <div class="list-group">
                                            @foreach (var s in ViewBag.AllSessions as List<SessaoKart>)
                                            {
                                                <label class="list-group-item">
                                                    <input type="checkbox" class="form-check-input me-1 session-checkbox" value="@s.NomeFicheiro" />
                                                    @s.NomeFicheiro
                                                </label>
                                            }
                                        </div>
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                                        <button type="button" id="confirmAddSessions" class="btn btn-primary">Adicionar</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>

        <div id="plotArea" style="width:100%; height:600px;"></div>
        <div class="d-flex align-items-start mt-4">
            @if (selectedProgressBars.Any())
            {
                <div id="gauges" class="d-flex justify-content-around mt-4" style="width:60%;">
                    @foreach (var ch in selectedProgressBars)
                    {
                        var key = ch.Replace(" ", "");
                        Console.WriteLine("key: " + key);
                        <div class="gauge-container">
                            <div class="fw-semibold mb-1">@ch</div>
                            <div class="max-label" id="max@(key)">—</div>
                            <div class="progress-vertical">
                                <div id="bar@(key)" class="progress-bar bg-primary"></div>
                                <span id="label@(key)" class="bar-label">0</span>
                            </div>
                            <div class="min-label" id="min@(key)">-</div>
                            <div class="current-label" id="Value@(key)">0</div>
                        </div>
                    }
                </div>
            }
            <div id="trackPlot" style="width:40%; height:400px; margin-top:2rem;"></div>
        </div>
    </div>
</div>

@{
    // Serializar dados para JS usando JSON
    var jsData = channelsByFile.ToDictionary(
        kv => kv.Key,
        kv => kv.Value.ToDictionary(
            ch => ch.Name,
            ch => new { times = ch.Times, values = ch.Values }
        )
    );
    var lapsByFile = ((Dictionary<string, double[]>)ViewBag.LapsByFile);
}

@section Scripts {
    <script>
        // 1) Dados vindos do C#
        const dataBySession = @Html.Raw(JsonConvert.SerializeObject(jsData));
        const lapsBySession = @Html.Raw(JsonConvert.SerializeObject(lapsByFile));
        const selectedGraphs = @Html.Raw(JsonConvert.SerializeObject(selectedGraphs));
        const selectedProgressBars = @Html.Raw(JsonConvert.SerializeObject(selectedProgressBars));
        let currentSession = '@firstSession';
        let maxValues = {}, minValues = {};
        let compareSelections = [];

        const plotChannels = selectedGraphs;
        const barChannels  = selectedProgressBars;

        // Para mapear nomes a sufixos de ID
        const idKey = {
            'RPM':          { bar:'RPM',    max:'maxRPM',    min:'minRPM',    curr:'ValueRPM'    },
            'Internal Battery':   { bar:'InternalBattery',   max:'maxInternalBattery',   min:'minInternalBattery',   curr:'ValueInternalBattery'   },
            'Water Temp':   { bar:'WaterTemp',   max:'maxWaterTemp',   min:'minWaterTemp',   curr:'ValueWaterTemp'   },
            'GPS LatAcc':   { bar:'GPSLatAcc', max:'maxGPSLatAcc', min:'minGPSLatAcc', curr:'ValueGPSLatAcc' },
            'GPS LonAcc':   { bar:'GPSLonAcc', max:'maxGPSLonAcc', min:'minGPSLonAcc', curr:'ValueGPSLonAcc' },
            'GPS Speed':    { bar:'GPSSpeed',    max:'maxGPSSpeed',    min:'minGPSSpeed',    curr:'ValueGPSSpeed' },
            'GPS Nsat':   { bar:'GPSNsat', max:'maxGPSNsat', min:'minGPSNsat', curr:'ValueGPSNsat' },
            'GPS Slope':   { bar:'GPSSlope', max:'maxGPSSlope', min:'minGPSSlope', curr:'ValueGPSSlope' },
            'GPS Altitude':   { bar:'GPSAltitude',   max:'maxGPSAltitude',   min:'minGPSAltitude',   curr:'ValueGPSAltitude' },
            'GPS PosAccuracy':   { bar:'GPSPosAccuracy', max:'maxGPSPosAccuracy', min:'minGPSPosAccuracy', curr:'ValueGPSPosAccuracy' },
            'GPS SpdAccuracy':   { bar:'GPSSpdAccuracy', max:'maxGPSSpdAccuracy', min:'minGPSSpdAccuracy', curr:'ValueGPSSpdAccuracy' },
            'GPS Latitude':    { bar:'GPSLatitude',    max:'maxGPSLatitude',    min:'minGPSLatitude',    curr:'ValueGPSLatitude' },
            'GPS Longitude':   { bar:'GPSLongitude', max:'maxGPSLongitude', min:'minGPSLongitude', curr:'ValueGPSLongitude' },
            'GPS Radius':   { bar:'GPSRadius', max:'maxGPSRadius', min:'minGPSRadius', curr:'ValueGPSRadius' },
            'GPS East':   { bar:'GPSEast',   max:'maxGPSEast',   min:'minGPSEast',   curr:'ValueGPSEast' },
            'GPS North':   { bar:'GPSNorth',   max:'maxGPSNorth',   min:'minGPSNorth',   curr:'ValueGPSNorth' },
            'GPS Gyro':     { bar:'GPSGyro', max:'maxGPSGyro', min:'minGPSGyro', curr:'ValueGPSGyro' },
            'GPS Heading':  { bar:'GPSHeading', max:'maxGPSHeading', min:'minGPSHeading', curr:'ValueGPSHeading' }
        };

        // 3) Calcula máximos para normalizar a largura das barras
        function calculaMaximos() {
            const sess = dataBySession[currentSession] || {};
            barChannels.forEach(ch => {
                const keys = idKey[ch] || {};
                const elMax = document.getElementById(keys.max);
                const elMin = document.getElementById(keys.min);
                const vals = sess[ch]?.values || [];
                const m = vals.length ? Math.max(...vals) : 0;
                const n = vals.length ? Math.min(...vals) : 0;
                maxValues[ch] = m;
                minValues[ch] = n;
                // Escreve o valor máximo no topo
                if (elMax) elMax.textContent = m.toFixed(2);
                else console.warn(`max element not found for ${ch} (id="${keys.max}")`);
                if (elMin) elMin.textContent = n.toFixed(2);
                else console.warn(`min element not found for ${ch} (id="${keys.min}")`);
            });
        }

        function plotAll(plotDivId) {
            if (compareSelections.length) plotCompare(plotDivId);
            else plotNormal(plotDivId);
        }

        function plotCompare(plotDivId) {
            const traces = [];
            const n      = plotChannels.length;
            const height = 1 / n;
            const layout = {
                hovermode: 'x unified',
                margin: { t: 20 },
                shapes: [],
                dragmode: false
            };

            // Configura os eixos verticalmente
            for (let i = 0; i < n; i++) {
                const xKey = 'xaxis' + (i === 0 ? '' : i + 1);
                const yKey = 'yaxis' + (i === 0 ? '' : i + 1);
                const titleY = (plotChannels[i] === 'GPS HeadGyro')
                    ? 'GPS Heading / GPS Gyro'
                    : plotChannels[i];

                layout[xKey] = {
                    domain: [0, 1],
                    anchor: yKey,
                    title: i === 0 ? 'Posição GPS (m)' : '',
                    fixedrange: true
                };
                layout[yKey] = {
                    domain: [i * height, i * height + height],
                    anchor: xKey,
                    title: titleY,
                    fixedrange: true
                };
            }

            // Determinar firstT0 e firstT1 com base na primeira seleção
            let firstT0 = 0, firstT1 = 0;
            if (compareSelections.length) {
                const firstSel = compareSelections[0];
                const sessData = dataBySession[firstSel.session] || {};
                const principais = plotChannels[0];
                const timesPrinc = sessData[principais]?.times || [];
                const ultimoTempo = timesPrinc[timesPrinc.length - 1] || 0;

                const rawLapDurations = lapsBySession[firstSel.session] || [];
                const lapEnds = [];
                let acum = 0;
                rawLapDurations.forEach(dur => {
                    acum += dur;
                    lapEnds.push(acum);
                });
                if (lapEnds.length === 0 || lapEnds[lapEnds.length - 1] < ultimoTempo) {
                    lapEnds.push(ultimoTempo);
                }

                const idxLap = firstSel.lap;
                if (idxLap >= 0 && idxLap < lapEnds.length) {
                    firstT1 = lapEnds[idxLap];
                    firstT0 = (idxLap > 0) ? lapEnds[idxLap - 1] : 0;
                }
            }

            compareSelections.forEach(sel => {
                const sessData = dataBySession[sel.session] || {};

                // 1) Extrair GPS (já em segundos, assumir que normalizeTimesToS foi chamado)
                const gpsLatTimes = sessData['GPS Latitude']?.times || [];
                const gpsLats     = sessData['GPS Latitude']?.values || [];
                const gpsLons     = sessData['GPS Longitude']?.values || [];
                if (gpsLatTimes.length < 2 || gpsLats.length < 2 || gpsLons.length < 2) {
                    console.warn(`Sem dados GPS suficientes para a sessão ${sel.session}`);
                    return;
                }

                // 2) Pré-cálculo de distâncias cumulativas
                const N = gpsLatTimes.length;
                const gpsDist = new Array(N);
                gpsDist[0] = 0;
                for (let i = 1; i < N; i++) {
                    const lat1 = gpsLats[i - 1], lon1 = gpsLons[i - 1];
                    const lat2 = gpsLats[i],     lon2 = gpsLons[i];
                    const toRad = Math.PI / 180;
                    const φ1 = lat1 * toRad;
                    const φ2 = lat2 * toRad;
                    const Δφ = (lat2 - lat1) * toRad;
                    const Δλ = (lon2 - lon1) * toRad;
                    const R = 6371000;
                    const a = Math.sin(Δφ / 2) ** 2 +
                              Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) ** 2;
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    gpsDist[i] = gpsDist[i - 1] + R * c;
                }

                // 3) Função de busca binária para encontrar o índice k / k+1
                function findTimeIndex(t) {
                    let lo = 0, hi = N - 1;
                    if (t <= gpsLatTimes[0]) return 0;
                    if (t >= gpsLatTimes[hi]) return hi;
                    while (lo < hi - 1) {
                        const mid = (lo + hi) >> 1;
                        if (gpsLatTimes[mid] <= t) lo = mid;
                        else hi = mid;
                    }
                    return lo; // garante gpsLatTimes[lo] <= t < gpsLatTimes[lo+1]
                }

                // 4) Função distAtTime com binária + interpolação
                function distAtTime(t) {
                    // antes do primeiro ou depois do último
                    if (t <= gpsLatTimes[0]) return gpsDist[0];
                    if (t >= gpsLatTimes[N - 1]) return gpsDist[N - 1];
                    const k = findTimeIndex(t);
                    const t0 = gpsLatTimes[k],   t1 = gpsLatTimes[k + 1];
                    const d0 = gpsDist[k],       d1 = gpsDist[k + 1];
                    const frac = (t - t0) / (t1 - t0);
                    return d0 + frac * (d1 - d0);
                }

                // 5) Determinar limites da volta em t e d
                const primeiras = plotChannels[0];
                const temposPainel = sessData[primeiras]?.times || [];
                const ultimoPainel = temposPainel[temposPainel.length - 1] || 0;
                let lapEnds = lapsBySession[sel.session] || [];
                if (lapEnds.length === 0 || lapEnds[lapEnds.length - 1] < ultimoPainel) {
                    lapEnds = lapEnds.concat(ultimoPainel);
                }
                const idxLap = sel.lap;
                if (idxLap < 0 || idxLap >= lapEnds.length) return;
                const t0 = idxLap > 0 ? lapEnds[idxLap - 1] : 0;
                const t1 = lapEnds[idxLap];
                const d0 = distAtTime(t0);

                // 6) Para cada canal, criar trace com x = distâncias - d0
                plotChannels.forEach((panel, i) => {
                    const channels = (panel === 'GPS HeadGyro')
                        ? ['GPS Heading', 'GPS Gyro']
                        : [panel];

                    channels.forEach(ch => {
                        const times = sessData[ch]?.times || [];
                        const vals  = sessData[ch]?.values || [];
                        if (!times.length || !vals.length) return;

                        const segX = [];
                        const segY = [];
                        const segT = [];  // tempo relativo para hover

                        for (let k = 0; k < times.length; k++) {
                            const tk = times[k];
                            if (tk < t0 || tk > t1) continue;
                            const distK = distAtTime(tk);
                            segX.push(distK - d0);
                            segY.push(vals[k]);
                            segT.push(tk - t0);
                        }

                        traces.push({
                            x: segX,
                            y: segY,
                            customdata: segT,
                            name: `${sel.session} Volta ${idxLap + 1} – ${ch}`,
                            mode: 'lines',
                            xaxis: 'x' + (i === 0 ? '' : i + 1),
                            yaxis: 'y' + (i === 0 ? '' : i + 1)
                        });
                    });
                });
            });

            Plotly.newPlot(
                plotDivId,
                traces,
                layout,
                {
                    modeBarButtonsToRemove: ['zoom2d', 'pan2d', 'autoScale2d', 'resetScale2d'],
                    displaylogo: false,
                    scrollZoom: false
                }
            ).then(gd => {
                gd.on('plotly_hover', ev => {
                    const pt = ev.points[0];
                    const timeRel = pt.customdata;
                    updateBars(timeRel);

                    // Cálculo de coord. no trackPlot
                    const tAbsol = firstT0 + timeRel;
                    const sess   = dataBySession[currentSession] || {};
                    const times  = sess['GPS Latitude']?.times  || [];
                    const latArr = sess['GPS Latitude']?.values || [];
                    const lonArr = sess['GPS Longitude']?.values || [];

                    // Encontrar índice com busca binária
                    let idx = 0, lo = 0, hi = times.length - 1;
                    if (tAbsol <= times[0]) idx = 0;
                    else if (tAbsol >= times[hi]) idx = hi;
                    else {
                        while (lo < hi - 1) {
                            const mid = (lo + hi) >> 1;
                            if (times[mid] <= tAbsol) lo = mid;
                            else hi = mid;
                        }
                        idx = lo;
                    }
                    const latP = latArr[idx];
                    const lonP = lonArr[idx];

                    Plotly.restyle('trackPlot',
                        { x: [[lonP]], y: [[latP]] },
                        [1]
                    );

                    const xDist = pt.x;
                    const hoverShape = {
                        type: 'line',
                        x0: xDist,
                        x1: xDist,
                        y0: 0,
                        y1: 1,
                        xref: 'x',
                        yref: 'paper',
                        line: { color: '#888', width: 1, dash: 'dot' }
                    };
                    Plotly.relayout(gd, { shapes: [hoverShape] });
                });

                gd.on('plotly_unhover', () => {
                    Plotly.restyle('trackPlot',
                        { x: [[]], y: [[]] },
                        [1]
                    );
                    Plotly.relayout(gd, { shapes: [] });
                });

                gd.on('plotly_relayout', e => {
                    const range = e['xaxis.range'];
                    if (!Array.isArray(range)) return;
                    const x0 = range[0];
                    const trace0 = gd.data[0];
                    // encontrar índice correspondente a x0 (que é distância)
                    let idx = 0;
                    // aqui podes usar busca linear ou binária, mas traços costumam ser menores
                    while (idx < trace0.x.length && trace0.x[idx] < x0) idx++;
                    if (idx >= trace0.x.length) idx = trace0.x.length - 1;
                    const timeRel = trace0.customdata[idx];

                    updateBars(timeRel);

                    const tAbsol = firstT0 + timeRel;
                    const sess   = dataBySession[currentSession] || {};
                    const times  = sess['GPS Latitude']?.times  || [];
                    const latArr = sess['GPS Latitude']?.values || [];
                    const lonArr = sess['GPS Longitude']?.values || [];

                    let i2 = 0, lo = 0, hi = times.length - 1;
                    if (tAbsol <= times[0]) i2 = 0;
                    else if (tAbsol >= times[hi]) i2 = hi;
                    else {
                        while (lo < hi - 1) {
                            const mid = (lo + hi) >> 1;
                            if (times[mid] <= tAbsol) lo = mid;
                            else hi = mid;
                        }
                        i2 = lo;
                    }
                    const latP = latArr[i2], lonP = lonArr[i2];

                    Plotly.restyle('trackPlot',
                        { x: [[lonP]], y: [[latP]] },
                        [1]
                    );
                });
            });
        }

        function plotNormal(plotDiv) {
            const sess   = dataBySession[currentSession] || {};
            const traces = [];
            const n      = plotChannels.length;
            const height = 1/n;
            const panels = plotChannels;

            const allTimes = sess[ plotChannels[0] ]?.times || [];
            const t0 = 0;
            const t1 = Math.max(...allTimes);

            // 1) obter array de tempos de volta
            const lapTimes = lapsBySession[currentSession] || [];

            const lapShapes = lapsBySession[currentSession].map(t => ({
                type:  'line',
                x0:    t,
                x1:    t,
                y0:    0,
                y1:    1,
                xref:  'x',
                yref:  'paper',
                line: {
                    color: 'red',
                    width: 1,
                    dash:  'dot'
                }
            }));

            // (calcula xMin/xMax dinamicamente se quiseres, mas com rangeslider não é obrigatório)
            const layout = {
                hovermode: 'x unified',
                margin:    { t: 20 },
                shapes:    [],
                dragmode: false    // desactiva drag dentro do gráfico
            };

            for (let i = 0; i < n; i++) {
                const panel   = panels[i];
                const rowBot = i*height, rowTop = rowBot+height;
                const xKey   = 'xaxis' + (i===0?'':i+1);
                const yKey   = 'yaxis' + (i===0?'':i+1);
                const titleY  = panel === 'GPS HeadGyro'
                                ? 'GPS HeadGyro'
                                : panel;

                layout[xKey] = {
                    domain:         [0,1],
                    anchor:         yKey,
                    title:          (i===0?'Time':''),
                    showline:       true,
                    showgrid:       false,
                    showticklabels: true,
                    ticks:          'outside',
                    mirror:         'ticks',
                    spikemode:      'across',
                    spikesnap:      'cursor',
                    spikecolor:     '#888',
                    range:          [t0, t1],
                    fixedrange:     true,

                    // apenas no primeiro eixo X:
                    ...(i===0 && {
                        rangeslider: {
                        visible:   true,
                        range:     [t0, t1],
                        thickness: 0.1    // 10% da altura do plot
                        },
                        rangeselector: {     // botões opcionais
                        buttons: [
                            { count: 1,  label: '1m', step: 'minute', stepmode: 'backward' },
                            { count: 5,  label: '5m', step: 'minute', stepmode: 'backward' },
                            { step: 'all' }
                        ]
                        }
                    }),

                    // faz com que todos os outros x-eixos sigam o principal
                    ...(i>0 && { matches: 'x' })
                };

                  layout[yKey] = {
                        domain:         [rowBot, rowTop],
                        anchor:         xKey,
                        title:          titleY,
                        showline:       true,
                        showticklabels: true,
                        ticks:          'outside',
                        fixedrange:     true    // bloqueia Y
                  };
            }

            // cria traces normalmente…
            plotChannels.forEach((panel,i) => {
                const channels = panel === 'GPS HeadGyro'
                                 ? ['GPS Heading','GPS Gyro']
                                 : [panel];
                channels.forEach(ch => {
                    const s = sess[ch];
                    if (!s) return;
                    traces.push({
                        x:     s.times,
                        y:     s.values,
                        name:  ch,
                        mode:  'lines',
                        meta:  ch,
                        hovertemplate: `<b>${ch}</b><br>%{y:.2f}<extra></extra>`,
                        xaxis: 'x' + (i===0?'':i+1),
                        yaxis: 'y' + (i===0?'':i+1)
                    });
                });
            });

            const config = {
                modeBarButtonsToRemove: [
                    'zoom2d','pan2d','zoomIn2d','zoomOut2d','autoScale2d','resetScale2d'
                ],
                displaylogo: false,
                scrollZoom: false
            };

            // 4) Desenha o grafico
            Plotly.newPlot(plotDiv, traces, layout, config)
                  .then(gd => {
                // 5) hover handlers (mantém o teu bloco original)
                gd.on('plotly_hover', ev => {
                    updateBars(ev);
                    const x = ev.points[0].x;

                    const times = dataBySession[currentSession]['GPS Latitude'].times;
                    const idx = bisectLeft(times, x);
                    // 2) obtém lat/lon desse índice
                    const lat = dataBySession[currentSession]['GPS Latitude'].values[idx];
                    const lon = dataBySession[currentSession]['GPS Longitude'].values[idx];
                    // 3) actualiza o ponto (trace 1) no trackPlot
                    Plotly.restyle('trackPlot',
                        { x: [[lon]], y: [[lat]] },
                        [1]   // segundo trace
                    );

                    const hoverShape = {
                        type: 'line', x0: x, x1: x,
                        y0: 0, y1: 1,
                        xref: 'x', yref: 'paper',
                        line: { color: '#888', width: 1, dash: 'dot' }
                    };
                    // junta lapShapes + linha de hover
                    Plotly.relayout(gd, { shapes: lapShapes.concat([hoverShape]) });
                });

                gd.on('plotly_unhover', () => {
                    // volta só às linhas de volta
                    Plotly.relayout(gd, { shapes: lapShapes });

                    // limpa o ponto
                    Plotly.restyle('trackPlot',
                        { x: [[]], y: [[]] },
                        [1]
                    );
                });

                gd.on('plotly_relayout', e => {
                    const range = e['xaxis.rangeslider.range'] ?? e['xaxis.range'];
                    if (!Array.isArray(range)) {
                    // veio só um relayout de shapes (hover), ignora
                        return;
                    }

                    let [x0, x1] = range;
                    // se for inválido, reverte ao último válido
                    if (x0 < 0 || x1 < x0 || x0 > t1|| x1 > t1) {
                      Plotly.relayout(gd, {
                        'xaxis.range':           [0, t1],
                        'xaxis.rangeslider.range': [0, t1]
                      });
                      return;
                    }

                    console.log('Rangeslider válido → x0:', x0, 'x1:', x1);
                    updateTrackPlotByTime(x0, x1);
                    updateBars({ points: [ { x: x0 } ] });
                });
            });
        }

        // encontra o índice mais próximo de um tempo
        function bisectLeft(arr, x) {
            let lo = 0, hi = arr.length;
            while (lo < hi) {
                const mid = (lo + hi) >> 1;
                if (arr[mid] < x) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        }

        function updateBars(ev) {
            let timeX;
            // Se for evento do Plotly Hover (com ev.points), usamos ev.points[0].x
            if (ev.points) {
                timeX = ev.points[0].x;
            } else {
                // Se for só um número, tomamos direto
                timeX = ev;
            }

            const sess  = dataBySession[currentSession] || {};
            barChannels.forEach(ch => {
                const { bar:key, curr:lbl } = idKey[ch];
                const times  = sess[ch]?.times  || [];
                const values = sess[ch]?.values || [];
                let idx = bisectLeft(times, timeX);
                if (idx >= values.length) idx = values.length - 1;
                const val = values[idx] ?? 0;

                // calcula percentagem entre min e max
                const min = minValues[ch], max = maxValues[ch];
                const pct = max!==min ? (val - min) / (max - min) * 100 : 0;
                document.getElementById('bar'+key).style.height = pct + '%';
                document.getElementById(lbl).textContent = val.toFixed(2);
            });
        }


        function normalizeTimesToS(sessionData) {
            const secChannels = ['GPS LatAcc','GPS LonAcc', 'GPS Speed', 'GPS Latitude','GPS Longitude', 'GPS North', 'GPS East','GPS Radius', 'GPS PosAccuracy','GPS SpdAccuracy','GPS Slope','GPS Heading','GPS Gyro'];
            secChannels.forEach(ch => {
                if (!sessionData[ch]) return;
                sessionData[ch].times = sessionData[ch].times.map(t => t / 1000);
            });
        }

        function plotTrack() {
            const sess = dataBySession[currentSession] || {};
            const lat = sess['GPS Latitude']?.values;
            const lon = sess['GPS Longitude']?.values;
            if (!lat?.length || !lon?.length) {
                console.warn('Sem dados GPS Latitude/Longitude suficientes para plotTrack');
            return;
            }

            const traceLine = {
                x: lon,
                y: lat,
                mode: 'lines',
                showlegend: false,
                line: { width: 2 }
            };

            const traceHover = {
                x: [],            // vai receber [lon]
                y: [],            // vai receber [lat]
                mode: 'markers',
                marker: { size: 8, color: 'red' },
                hoverinfo: 'none',
                showlegend: false
            };

            const layout = {
                xaxis: {
                    visible:    false,    // retira linha, grelha, ticks, rótulos, título
                    autorange:  true,
                    scaleanchor: 'y',     // mantém a proporção 1:1
                    scaleratio: 1
                },
                yaxis: {
                    visible:   false,     // retira linha, grelha, ticks, rótulos, título
                    autorange: true
                },
                margin: { t: 30, l: 50, r: 30, b: 50 }
            };

            const config = {
                displayModeBar: true,
                modeBarButtons: [
                  ['toImage']            // só o botão “Download plot as a png”
                ],
                displaylogo: false,
                scrollZoom: false,
                responsive: true
            };
            Plotly.newPlot('trackPlot', [traceLine, traceHover], layout, config);
        }

        function updateTrackPlotByTime(t0, t1) {
            const sess = dataBySession[currentSession] || {};
            const times = sess['GPS Latitude']?.times  || [];
            const lat   = sess['GPS Latitude']?.values || [];
            const lon   = sess['GPS Longitude']?.values || [];

            const newLat = [];
            const newLon = [];
            for (let i = 0; i < times.length; i++) {
                if (times[i] >= t0 && times[i] <= t1) {
                    newLat.push(lat[i]);
                    newLon.push(lon[i]);
                }
            }

            // 1) Atualiza só os dados do trace
            Plotly.restyle('trackPlot',
                { x: [newLon], y: [newLat] },
                [0]
            );

            // e força autorange de novo
            Plotly.relayout('trackPlot', {
                'xaxis.autorange': true,
                'yaxis.autorange': true
            });
        }

        const btnShow   = document.getElementById('btnShowDetails');
        const btnHide   = document.getElementById('btnHideDetails');
        const sidePanel = document.getElementById('sidePanel');

        document.getElementById('confirmCompareLaps').addEventListener('click', () => {
            const boxes = document.querySelectorAll('.compare-lap-checkbox:checked');
            const sels = Array.from(boxes).map(cb => ({
                session: cb.dataset.session,
                lap:     parseInt(cb.value,10)
            }));
            if (!sels.length) {
                alert('Seleciona pelo menos uma volta para comparar.');
                return;
            }
            compareSelections = sels;
            // Fecha o modal
            const modalEl = document.getElementById('compareLapsModal');
            const modal = bootstrap.Modal.getInstance(modalEl);
            modal.hide();
            plotAll('plotArea');
        });

        btnShow.addEventListener('click', () => {
            sidePanel.classList.add('open');
        });

        btnHide.addEventListener('click', () => {
            sidePanel.classList.remove('open');
        });

        // Fecha panel ao clicar fora
        document.addEventListener('click', (e) => {
            if (sidePanel.classList.contains('open') && !sidePanel.contains(e.target) && e.target !== btnShow) {
                sidePanel.classList.remove('open');
            }
        });

        document.getElementById('confirmAddSessions').addEventListener('click', () => {
            const selecionadas = Array.from(document.querySelectorAll('.session-checkbox:checked'))
                                     .map(cb => cb.value);
            if (!selecionadas.length) {
                alert('Seleciona pelo menos uma sessão.');
                return;
            }
            // Merge com sessões já existentes na querystring
            const params = new URLSearchParams(window.location.search);
            const existentes = params.get('ficheiros')
                               ? params.get('ficheiros').split(',')
                               : [];
            const combined = Array.from(new Set([...existentes, ...selecionadas]));
            params.set('ficheiros', combined.join(','));
            window.location.href = `${window.location.pathname}?${params}`;
        });

        // Remove sessão ao clicar no lixo
        document.getElementById('sessionTable').addEventListener('click', e => {
            if (e.target.closest('.btn-remove')) {
                e.stopPropagation();
                const row = e.target.closest('tr');
                const sess = row.dataset.session;
                const params = new URLSearchParams(window.location.search);
                const list = params.get('ficheiros') ? params.get('ficheiros').split(',') : [];
                const updated = list.filter(f => f !== sess);
                params.set('ficheiros', updated.join(','));
                // recarrega sem essa sessão
                window.location.href = `${window.location.pathname}?${params}`;
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const rows    = document.querySelectorAll('#sessionTable .clickable-row');
            const details = document.querySelectorAll('.channel-details');
            const plotArea  = document.getElementById('plotArea');

            Object.values(dataBySession).forEach(sessData => {
                normalizeTimesToS(sessData);
            });

            calculaMaximos();
            plotAll(plotArea);
            plotTrack();

            rows.forEach(row => {
                row.addEventListener('click', () => {
                    // 1) Sair do modo “Comparar Voltas”
                    compareSelections = [];
                    document.querySelectorAll('.compare-lap-checkbox').forEach(cb => cb.checked = false);
                    // Se o modal de comparar estiver aberto, fecha-o
                    const compareModalEl = document.getElementById('compareLapsModal');
                    const compareModal = bootstrap.Modal.getInstance(compareModalEl);
                    if (compareModal) compareModal.hide();

                    // Destaque na tabela
                    rows.forEach(r => r.classList.remove('table-active'));
                    row.classList.add('table-active');

                    const sessionId = row.dataset.session;
                    console.log('Sessão clicada:', sessionId);

                    // Mostrar/esconder detalhes
                    details.forEach(div => {
                        div.classList.toggle('d-none', div.dataset.session !== sessionId);
                    });

                    currentSession = sessionId;
                    calculaMaximos();
                    plotAll(plotArea);
                    plotTrack();

                    updateBars(0);
                });
            });
        });
    </script>
}
