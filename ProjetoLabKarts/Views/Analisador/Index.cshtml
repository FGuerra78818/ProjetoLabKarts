@model IEnumerable<ProjetoLabKarts.Models.SessaoKart>
@using ProjetoLabKarts.Interop
@using System.Globalization
@using Newtonsoft.Json

@{
    ViewData["Title"] = "Análise de Sessões";
    var channelsByFile = (Dictionary<string, List<ChannelData>>)ViewBag.ChannelsByFile;
    var firstSession = Model.FirstOrDefault()?.NomeFicheiro;
}

<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <style>
        /* Painel lateral esquerdo 30% */
        .side-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 30%; /* ocupa 30% da largura */
            height: 100%;
            background: #fff; /* ou o que te apetecer */
            box-shadow: 2px 0 8px rgba(0,0,0,0.3);
            z-index: 9999;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: transform .3s ease-in-out;
        }

            .side-panel.open {
                transform: translateX(0);
            }

            .side-panel .panel-header {
                padding: 1rem;
                border-bottom: 1px solid #ddd;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .side-panel .panel-body {
                padding: 1rem;
            }

        .d-none {
            display: none !important;
        }

        .chart-row {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
        }

        .chart {
            background: #222;
            padding: 5px;
            border-radius: 4px;
        }

        #gauges {
            display: flex;
            justify-content: space-around;
            margin: 10px;
        }

        .gauge {
            width: 180px;
            height: 180px;
        }

        .progress-vertical {
            width: 1.5rem;
            height: 200px; /* altura total da barra */
            background: #e9ecef;
            border-radius: 0.25rem;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse; /* o “fundo” fica em baixo */
            margin: 0 auto;
        }

            .progress-vertical .progress-bar {
                width: 100%;
                height: 0%; /* vai crescer em altura */
                transition: height .2s ease;
                position: relative;
                display: flex;
                align-items: flex-end;
                justify-content: center;
            }

        .gauge-container {
            text-align: center;
        }

            .gauge-container .max-label .min-label {
                font-size: .8rem;
                margin-bottom: .25rem;
            }

            .gauge-container .current-label {
                font-size: .9rem;
                margin-top: .25rem;
            }

        .bar-label {
            position: absolute;
            bottom: 0.25rem; /* fixa junto ao fundo da barra */
            left: 50%; /* centra horizontalmente */
            transform: translateX(-50%);
            font-size: .75rem;
            color: #fff;
            pointer-events: none; /* para que não interfira no hover */
        }
    </style>
</head>

<div class="container modal-fullscreen">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div class="d-flex flex-column">
            <h2 class="mb-0">Sessões Selecionadas para Análise</h2>
            <p class="lead fs-6 mb-0">Análise da telemetria das sessões</p>
        </div>

        <div class="d-flex align-items-center gap-2">
            <button id="btnShowDetails" class="btn btn-primary">
                Ver Detalhes dos Canais
            </button>

            <button type="button"
                    onclick="window.history.back();"
                    class="btn btn-outline-secondary">
                ← Voltar
            </button>
        </div>
    </div>


    <div class="row g-3 mb-4 align-items-stretch">
        <div class="col-md-4">
            <div class="card shadow border rounded-3 p-2 h-100">
                <div class="card-body d-flex flex-column gap-2">
                    <h5 class="card-title">Melhor Volta</h5>
                    <h3 class="card-text fw-bold">@ViewBag.melhorVolta</h3>
                    <small class="text-muted">
                        -@ViewBag.diferencaMelhorVoltaDosOutrosFicheiros para a Melhor Volta dos outros ficheiros
                    </small>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card shadow border p-2 h-100">
                <div class="card-body d-flex flex-column gap-2">
                    <h5 class="card-title">Número de Voltas</h5>
                    <h3 class="card-text fw-bold">@ViewBag.numeroDeVoltas</h3>
                    <small class="text-muted"></small>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card shadow border p-2 h-100">
                <div class="card-body d-flex flex-column gap-2">
                    <h5 class="card-title">Velocidade Máxima</h5>
                    <h3 class="card-text fw-bold">@ViewBag.velocidadeMaxima km/h</h3>
                    <small class="text-muted">
                        +@ViewBag.diferencaVelocidadeMaximaDosOutrosFicheiros para a Velocidade Máxima dos outros ficheiros
                    </small>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <!-- SidePanel com tabelas -->
        <div class="col-lg-5">

            @if (!Model.Any())
            {
                <div class="alert alert-warning">Nenhuma sessão foi selecionada.</div>
            }
            else
            {
                <div id="sidePanel" class="side-panel">
                    <div class="panel-header">
                        <h5>Detalhe dos Canais</h5>
                        <button id="btnHideDetails" class="btn-close" aria-label="Fechar"></button>
                    </div>

                    <div class="panel-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5>Sessões Carregadas</h5>
                            <button id="btnAddSession" class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#addSessionModal">+</button>
                        </div>

                        <!-- 1ª Tabela clicável -->
                        <table class="table table-borderless mb-4" id="sessionTable">
                            <tbody>
                                @foreach (var s in Model)
                                {
                                    var isActive = s.NomeFicheiro == firstSession ? "table-active" : "";
                                    <tr class="clickable-row @isActive" data-session="@s.NomeFicheiro" style="cursor:pointer">
                                        <td class="fw-semibold text-muted">
                                            @s.MelhorVolta - @s.NumeroMelhorVolta
                                        </td>
                                        <td class="text-end text-muted" style="white-space: nowrap;">
                                            @s.DataHoraInsercao.ToString("yyyy, MMM dd h:mm tt", System.Globalization.CultureInfo.InvariantCulture)
                                        </td>
                                        <td class="text-end">
                                            <button type="button" class="btn btn-sm btn-outline-danger btn-remove" title="Remover">
                                                <i class="bi bi-trash"></i>
                                            </button>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>

                        <!-- 2ª Tabela de detalhes -->
                        <h5>Detalhe dos Canais de Telemetria</h5>
                        <div id="channelDetails">
                            @foreach (var s in Model)
                            {
                                var isVisible = s.NomeFicheiro == firstSession ? "" : "d-none";
                                <div class="channel-details @isVisible" data-session="@s.NomeFicheiro">
                                    <div class="table-responsive mb-4">
                                        <table class="table table-borderless align-middle">
                                            <thead class="text-muted border-bottom">
                                                <tr>
                                                    <th>Canal</th>
                                                    <th>Unidades</th>
                                                    <th># Pontos</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                @{
                                                    var canais = channelsByFile[s.NomeFicheiro];
                                                }
                                                @foreach (var ch in canais)
                                                {
                                                    <tr>
                                                        <td>@ch.Name</td>
                                                        <td>@ch.Units</td>
                                                        <td>@ch.Values.Length</td>
                                                    </tr>
                                                }
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            }
                        </div>

                        <!-- Modal de Adicionar Sessão sem filtragem -->
                        <div class="modal fade" id="addSessionModal" tabindex="-1" aria-labelledby="addSessionLabel" aria-hidden="true">
                            <div class="modal-dialog modal-lg">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 id="addSessionLabel" class="modal-title">Adicionar Sessões</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                                    </div>
                                    <div class="modal-body">
                                        <div class="list-group">
                                            @foreach (var s in ViewBag.AllSessions as List<SessaoKart>)
                                            {
                                                <label class="list-group-item">
                                                    <input type="checkbox" class="form-check-input me-1 session-checkbox" value="@s.NomeFicheiro" />
                                                    @s.NomeFicheiro
                                                </label>
                                            }
                                        </div>
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                                        <button type="button" id="confirmAddSessions" class="btn btn-primary">Adicionar</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>

        <div id="plotArea" style="width:100%; height:600px;"></div>
        <div id="gauges" class="d-flex justify-content-around mt-4">
            <!-- RPM -->
            <div class="gauge-container">
                <div class="max-label" id="maxRPM">—</div>
                <div class="progress-vertical">
                    <div id="barRPM" class="progress-bar bg-primary"></div>
                    <span id="labelRPM" class="bar-label">0</span>
                </div>
                <div class="min-label" id="minRPM">-</div>
                <div class="current-label" id="rpmValue">0</div>
            </div>

            <!-- GPS LatAcc -->
            <div class="gauge-container">
                <div class="max-label" id="maxLatAcc">—</div>
                <div class="progress-vertical">
                    <div id="barLatAcc" class="progress-bar bg-success"></div>
                    <span id="labelLatAcc" class="bar-label">0</span>
                </div>
                <div class="min-label" id="minLatAcc">-</div>
                <div class="current-label" id="latAccValue">0</div>
            </div>

            <!-- GPS LonAcc -->
            <div class="gauge-container">
                <div class="max-label" id="maxLonAcc">—</div>
                <div class="progress-vertical">
                    <div id="barLonAcc" class="progress-bar bg-warning"></div>
                    <span id="labelLonAcc" class="bar-label">0</span>
                </div>
                <div class="min-label" id="minLonAcc">-</div>
                <div class="current-label" id="lonAccValue">0</div>
            </div>

            <!-- Water Temp -->
            <div class="gauge-container">
                <div class="max-label" id="maxTemp">—</div>
                <div class="progress-vertical">
                    <div id="barTemp" class="progress-bar bg-info"></div>
                    <span id="labelTemp" class="bar-label">0</span>
                </div>
                <div class="min-label" id="minTemp">-</div>
                <div class="current-label" id="tempValue">0</div>
            </div>
            <div id="trackPlot" style="width:50%; height:400px; margin-top:2rem;"></div>
        </div>
    </div>
</div>

@{
    // Serializar dados para JS usando JSON
    var jsData = channelsByFile.ToDictionary(
        kv => kv.Key,
        kv => kv.Value.ToDictionary(
            ch => ch.Name,
            ch => new { times = ch.Times, values = ch.Values }
        )
    );
    var lapsByFile = ((Dictionary<string, double[]>)ViewBag.LapsByFile);
}

@section Scripts {
    <script>
        // 1) Dados vindos do C#
        const dataBySession = @Html.Raw(JsonConvert.SerializeObject(jsData));
        const lapsBySession = @Html.Raw(JsonConvert.SerializeObject(lapsByFile));
        let currentSession    = '@firstSession';
        let maxValues = {}, minValues = {};

        // 2) Quais os canais que queremos nas barras
        const barChannels  = ['RPM','GPS LatAcc','GPS LonAcc','Water Temp'];
        // Se quiseres incluir Speed no gráfico, faz um array separado:
        const plotChannels = ['GPS Speed', 'RPM','GPS LatAcc','GPS LonAcc'];

        // Para mapear nomes a sufixos de ID
        const idKey = {
            'RPM':        { bar:'RPM',    max:'maxRPM',    min:'minRPM',    curr:'rpmValue'    },
            'GPS LatAcc': { bar:'LatAcc', max:'maxLatAcc', min:'minLatAcc', curr:'latAccValue' },
            'GPS LonAcc': { bar:'LonAcc', max:'maxLonAcc', min:'minLonAcc', curr:'lonAccValue' },
            'Water Temp': { bar:'Temp',   max:'maxTemp',   min:'minTemp',   curr:'tempValue'   }
        };

        // 3) Calcula máximos para normalizar a largura das barras
        function calculaMaximos() {
            const sess = dataBySession[currentSession] || {};
            barChannels.forEach(ch => {
                const vals = sess[ch]?.values || [];
                const m = vals.length ? Math.max(...vals) : 0;
                const n = vals.length ? Math.min(...vals) : 0;
                maxValues[ch] = m;
                minValues[ch] = n;
                // Escreve o valor máximo no topo
                document.getElementById(idKey[ch].max).textContent = m.toFixed(2);
                document.getElementById(idKey[ch].min).textContent = n.toFixed(2);
            });
        }

        function plotAll(plotDiv) {
            const sess   = dataBySession[currentSession] || {};
            const traces = [];
            const n      = plotChannels.length;
            const height = 1/n;

            const allTimes = sess[ plotChannels[0] ]?.times || [];
            const t0 = 0;
            const t1 = Math.max(...allTimes);

            // 1) obter array de tempos de volta
            const lapTimes = lapsBySession[currentSession] || [];

            const lapShapes = lapsBySession[currentSession].map(t => ({
                type:  'line',
                x0:    t,
                x1:    t,
                y0:    0,
                y1:    1,
                xref:  'x',
                yref:  'paper',
                line: {
                    color: 'red',
                    width: 1,
                    dash:  'dot'
                }
            }));

            // (calcula xMin/xMax dinamicamente se quiseres, mas com rangeslider não é obrigatório)
            const layout = {
                hovermode: 'x unified',
                margin:    { t: 20 },
                shapes:    [],
                dragmode: false    // desactiva drag dentro do gráfico
            };

            for (let i = 0; i < n; i++) {
                const rowBot = i*height, rowTop = rowBot+height;
                const xKey   = 'xaxis' + (i===0?'':i+1);
                const yKey   = 'yaxis' + (i===0?'':i+1);

                layout[xKey] = {
                    domain:         [0,1],
                    anchor:         yKey,
                    title:          (i===0?'Time':''),
                    showline:       true,
                    showgrid:       false,
                    showticklabels: true,
                    ticks:          'outside',
                    mirror:         'ticks',
                    spikemode:      'across',
                    spikesnap:      'cursor',
                    spikecolor:     '#888',
                    range:          [t0, t1],
                    fixedrange:     true,

                    // apenas no primeiro eixo X:
                    ...(i===0 && {
                        rangeslider: {
                        visible:   true,
                        range:     [t0, t1],
                        thickness: 0.1    // 10% da altura do plot
                        },
                        rangeselector: {     // botões opcionais
                        buttons: [
                            { count: 1,  label: '1m', step: 'minute', stepmode: 'backward' },
                            { count: 5,  label: '5m', step: 'minute', stepmode: 'backward' },
                            { step: 'all' }
                        ]
                        }
                    }),

                    // faz com que todos os outros x-eixos sigam o principal
                    ...(i>0 && { matches: 'x' })
                };

                  layout[yKey] = {
                        domain:         [rowBot, rowTop],
                        anchor:         xKey,
                        title:          plotChannels[i],
                        showline:       true,
                        showticklabels: true,
                        ticks:          'outside',
                        fixedrange:     true    // bloqueia Y
                  };
            }

            // cria traces normalmente…
            plotChannels.forEach((ch,i) => {
                const s = sess[ch];
                if (!s) return;
                traces.push({
                    x:     s.times,
                    y:     s.values,
                    name:  ch,
                    mode:  'lines',
                    meta:  ch,
                    hovertemplate: `<b>${ch}</b><br>%{y:.2f}<extra></extra>`,
                    xaxis: 'x' + (i===0?'':i+1),
                    yaxis: 'y' + (i===0?'':i+1)
                });
            });

            const config = {
                modeBarButtonsToRemove: [
                    'zoom2d','pan2d','zoomIn2d','zoomOut2d','autoScale2d','resetScale2d'
                ],
                displaylogo: false,
                scrollZoom: false
            };

            // 4) Desenha o grafico
            Plotly.newPlot(plotDiv, traces, layout, config)
                  .then(gd => {
                // 5) hover handlers (mantém o teu bloco original)
                gd.on('plotly_hover', ev => {
                    updateBars(ev);
                    const x = ev.points[0].x;

                    const times = dataBySession[currentSession]['GPS Latitude'].times;
                    const idx = bisectLeft(times, x);
                    // 2) obtém lat/lon desse índice
                    const lat = dataBySession[currentSession]['GPS Latitude'].values[idx];
                    const lon = dataBySession[currentSession]['GPS Longitude'].values[idx];
                    // 3) actualiza o ponto (trace 1) no trackPlot
                    Plotly.restyle('trackPlot',
                        { x: [[lon]], y: [[lat]] },
                        [1]   // segundo trace
                    );

                    const hoverShape = {
                        type: 'line', x0: x, x1: x,
                        y0: 0, y1: 1,
                        xref: 'x', yref: 'paper',
                        line: { color: '#888', width: 1, dash: 'dot' }
                    };
                    // junta lapShapes + linha de hover
                    Plotly.relayout(gd, { shapes: lapShapes.concat([hoverShape]) });
                });

                gd.on('plotly_unhover', () => {
                    // volta só às linhas de volta
                    Plotly.relayout(gd, { shapes: lapShapes });

                    // limpa o ponto
                    Plotly.restyle('trackPlot',
                        { x: [[]], y: [[]] },
                        [1]
                    );
                });

                gd.on('plotly_relayout', e => {
                    const range = e['xaxis.rangeslider.range'] ?? e['xaxis.range'];
                    if (!Array.isArray(range)) {
                    // veio só um relayout de shapes (hover), ignora
                        return;
                    }

                    let [x0, x1] = range;
                    // se for inválido, reverte ao último válido
                    if (x0 < 0 || x1 < x0 || x0 > t1|| x1 > t1) {
                      Plotly.relayout(gd, {
                        'xaxis.range':           [0, t1],
                        'xaxis.rangeslider.range': [0, t1]
                      });
                      return;
                    }

                    console.log('Rangeslider válido → x0:', x0, 'x1:', x1);
                    updateTrackPlotByTime(x0, x1);
                });
            });
        }


        // encontra o índice mais próximo de um tempo
        function bisectLeft(arr, x) {
            let lo = 0, hi = arr.length;
            while (lo < hi) {
                const mid = (lo + hi) >> 1;
                if (arr[mid] < x) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        }

        function updateBars(ev) {
            const sess  = dataBySession[currentSession] || {};
            const timeX = ev.points[0].x;
            barChannels.forEach(ch => {
                const { bar:key, curr:lbl } = idKey[ch];
                const times  = sess[ch]?.times  || [];
                const values = sess[ch]?.values || [];
                let idx = bisectLeft(times, timeX);
                if (idx >= values.length) idx = values.length - 1;
                const val = values[idx] ?? 0;

                // calcula percentagem entre min e max
                const min = minValues[ch], max = maxValues[ch];
                const pct = max!==min ? (val - min) / (max - min) * 100 : 0;
                document.getElementById('bar'+key).style.height = pct + '%';
                document.getElementById(lbl).textContent = val.toFixed(2);
            });
        }


        function normalizeTimesToS(sessionData) {
            const secChannels = ['GPS LatAcc','GPS LonAcc', 'GPS Speed', 'GPS Latitude','GPS Longitude'];
            secChannels.forEach(ch => {
                if (!sessionData[ch]) return;
                sessionData[ch].times = sessionData[ch].times.map(t => t / 1000);
            });
        }

        function plotTrack() {
            const sess = dataBySession[currentSession] || {};
            const lat = sess['GPS Latitude']?.values;
            const lon = sess['GPS Longitude']?.values;
            if (!lat?.length || !lon?.length) {
                console.warn('Sem dados GPS Latitude/Longitude suficientes para plotTrack');
            return;
            }

            const traceLine = {
                x: lon,
                y: lat,
                mode: 'lines',
                showlegend: false,
                line: { width: 2 }
            };

            const traceHover = {
                x: [],            // vai receber [lon]
                y: [],            // vai receber [lat]
                mode: 'markers',
                marker: { size: 8, color: 'red' },
                hoverinfo: 'none',
                showlegend: false
            };

            const layout = {
                xaxis: {
                    visible:    false,    // retira linha, grelha, ticks, rótulos, título
                    autorange:  true,
                    scaleanchor: 'y',     // mantém a proporção 1:1
                    scaleratio: 1
                },
                yaxis: {
                    visible:   false,     // retira linha, grelha, ticks, rótulos, título
                    autorange: true
                },
                margin: { t: 30, l: 50, r: 30, b: 50 }
            };

            const config = {
                displayModeBar: true,
                modeBarButtons: [
                  ['toImage']            // só o botão “Download plot as a png”
                ],
                displaylogo: false,
                scrollZoom: false,
                responsive: true
            };
            Plotly.newPlot('trackPlot', [traceLine, traceHover], layout, config);
        }

        function updateTrackPlotByTime(t0, t1) {
            const sess = dataBySession[currentSession] || {};
            const times = sess['GPS Latitude']?.times  || [];
            const lat   = sess['GPS Latitude']?.values || [];
            const lon   = sess['GPS Longitude']?.values || [];

            const newLat = [];
            const newLon = [];
            for (let i = 0; i < times.length; i++) {
                if (times[i] >= t0 && times[i] <= t1) {
                    newLat.push(lat[i]);
                    newLon.push(lon[i]);
                }
            }

            // 1) Atualiza só os dados do trace
            Plotly.restyle('trackPlot',
                { x: [newLon], y: [newLat] },
                [0]
            );

            // e força autorange de novo
            Plotly.relayout('trackPlot', {
                'xaxis.autorange': true,
                'yaxis.autorange': true
            });
        }

        const btnShow   = document.getElementById('btnShowDetails');
        const btnHide   = document.getElementById('btnHideDetails');
        const sidePanel = document.getElementById('sidePanel');

        btnShow.addEventListener('click', () => {
            sidePanel.classList.add('open');
        });

        btnHide.addEventListener('click', () => {
            sidePanel.classList.remove('open');
        });

        // Fecha panel ao clicar fora
        document.addEventListener('click', (e) => {
            if (sidePanel.classList.contains('open') && !sidePanel.contains(e.target) && e.target !== btnShow) {
                sidePanel.classList.remove('open');
            }
        });

        document.getElementById('confirmAddSessions').addEventListener('click', () => {
            const selecionadas = Array.from(document.querySelectorAll('.session-checkbox:checked'))
                                     .map(cb => cb.value);
            if (!selecionadas.length) {
                alert('Seleciona pelo menos uma sessão.');
                return;
            }
            // Merge com sessões já existentes na querystring
            const params = new URLSearchParams(window.location.search);
            const existentes = params.get('ficheiros')
                               ? params.get('ficheiros').split(',')
                               : [];
            const combined = Array.from(new Set([...existentes, ...selecionadas]));
            params.set('ficheiros', combined.join(','));
            window.location.href = `${window.location.pathname}?${params}`;
        });

        // Remove sessão ao clicar no lixo
        document.getElementById('sessionTable').addEventListener('click', e => {
            if (e.target.closest('.btn-remove')) {
                e.stopPropagation();
                const row = e.target.closest('tr');
                const sess = row.dataset.session;
                const params = new URLSearchParams(window.location.search);
                const list = params.get('ficheiros') ? params.get('ficheiros').split(',') : [];
                const updated = list.filter(f => f !== sess);
                params.set('ficheiros', updated.join(','));
                // recarrega sem essa sessão
                window.location.href = `${window.location.pathname}?${params}`;
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const rows    = document.querySelectorAll('#sessionTable .clickable-row');
            const details = document.querySelectorAll('.channel-details');

            rows.forEach(row => {
                row.addEventListener('click', () => {
                    // Destaque na tabela
                    rows.forEach(r => r.classList.remove('table-active'));
                    row.classList.add('table-active');

                    const sessionId = row.dataset.session;
                    // Mostrar/esconder detalhes
                    details.forEach(div => {
                        div.classList.toggle('d-none', div.dataset.session !== sessionId);
                    });
                });
            });

            const sess = dataBySession[currentSession];
            normalizeTimesToS(sess);

            const plotArea = document.getElementById('plotArea');
            if (!plotArea) {
              console.error('#plotArea não encontrado no DOM');
              return;
            }

            calculaMaximos();
            plotAll(plotArea);
            plotTrack();

            plotArea.on('plotly_hover', updateBars);
        });
    </script>
}
